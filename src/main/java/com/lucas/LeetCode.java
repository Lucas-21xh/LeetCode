package com.lucas;import jdk.nashorn.internal.ir.annotations.Ignore;import java.util.*;import static jdk.nashorn.internal.objects.Global.print;/** * @author yangliang * @date 2021/2/7 */public class LeetCode {    public static int removeDuplicates(int[] nums) {     /*   for (int i = 1 ; i < nums.length ; i ++) {            if(nums[i-1] == nums[i]){                nums[i] = nums [i+1];                return nums[i];            }            return nums[i];        }        return 1;*/        int i=0,j=1;        while(j<nums.length){            if(nums[i] == nums[j]){                j++;            }else{                nums[++i] = nums[j];            }        }        return i+1;    }    public static int removeElement(int[] nums, int val) {        if (nums == null || nums.length == 0){            return 0;        }        int j = 0;        for (int i = 0; i < nums.length; i++) {            if (nums[i] != val) {                nums[j] = nums[i];                j++;            }        }        return j;    }    //给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。    public static int strStr(String haystack, String needle) {        int i = haystack.indexOf(needle);        return i;    }    public static int findMaxConsecutiveOnes(int[] nums) {        StringBuilder sb = new StringBuilder();        for (int i = 0; i < nums.length; i++) {            sb.append(nums[i]);        }        String s = sb.toString();        System.out.println("s"+s.toString());        String[] split = s.split("0");        int max = 0;        for (String s1 : split) {            System.out.println(s1);            int len = s1.length();            System.out.println("len "+len);            if (len > max) {                max = len;            }        }        return max;    }    public static int reverse(int x) {        int result = 0;        while(x != 0) {            // 保存计算之前的结果            int tmp = result;            result = (result * 10) + (x % 10);            x /= 10;            System.out.println("result "+ result);            System.out.println("x "+ x);            // 将计算之后的结果 / 10，判断是否与计算之前相同，如果不同，证明发生溢出，返回0            if (result / 10 != tmp) {return 0;}        }        return result;        }        /**         *回文判断         * @author yangliang         * @date 2021/2/15         * @param x         * @return boolean         */    public static boolean  isPalindrome(int x) {        if (x >= 0){            //i为逆转后的数            int i = x;            //j为存储十位以前的数            int j = 0;            while (i != 0) {                j = (j * 10) + (i % 10);                i = i /10;            }            return j == x;        }else {            return false;        }    }    /**     *罗马数字转整数     * 首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，     * 如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。     * 以此类推到最左边的数，最终得到的结果即是答案     * @author yangliang     * @date 2021/2/15     * @param s     * @return int     */    public static int romanToInt(String s) {        /*Map<String,Integer> map = new HashMap<>();        map.put("I",1);        map.put("V",5);        map.put("X",10);        map.put("L",50);        map.put("C",100);        map.put("D",500);        map.put("M",1000);        map.put("A",4);        map.put("B",9);        map.put("Q",40);        map.put("P",90);        map.put("E",400);        map.put("F",900);*/        s = s.replace("IV","A").replace("IX","B").                replace("XL","Q").                replace("XC","P").                replace("CD","E").                replace("CM","F");        Integer sum = 0;        for (int i = 0; i < s.length(); i++) {            String substring = s.substring(i, i + 1);            char c = s.charAt(i);            System.out.println(c);            int current = 0;            switch (substring){                case "I": current = 1; break;                case "V": current = 5; break;                case "X": current = 10; break;                case "L": current = 50; break;                case "C": current = 100; break;                case "D": current = 500; break;                case "M": current = 1000; break;                case "A": current = 4; break;                case "B": current = 9; break;                case "Q": current = 40; break;                case "P": current = 90; break;                case "E": current = 400; break;                case "F": current = 900; break;                default: break;            }            sum += current;            // sum += map.get(substring);        }        return sum;    }    /**     *数组拆分     * 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对     * 例如 (a1, b1), (a2, b2), ..., (an, bn)     * 使得从 1 到 n 的 min(ai, bi) 总和最大。     *     * 返回该 最大总和 。     */    public static int arrayPairSum(int[] nums) {        Arrays.sort(nums);        int sum = 0;        for (int i = 0; i < nums.length; i = i+2) {            sum += nums[i];        }        return sum;    }    /**     *编写一个函数来查找字符串数组中的最长公共前缀。     * 如果不存在公共前缀，返回空字符串 ""。     */    public String longestCommonPrefix(String[] strs) {        if (strs == null || strs.length == 0){            return "";        }        //纵向扫描        int length = strs[0].length();        int count = strs.length;        //i所有的横向扫描        for (int i = 0; i < length; i++) {            char c = strs[0].charAt(i);           //j所有的纵向扫描            for (int j = 0; j < count; j++) {                //如果长度相同并且当前列的值与第一个不同,出现最长的公共序列                if (i == strs[j].length() || strs[j].charAt(i) != c ){                    return strs[0].substring(0,i);                }            }        }        return strs[0];        }    /**     给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。     有效字符串需满足：     左括号必须用相同类型的右括号闭合。     左括号必须以正确的顺序闭合。     */    public static boolean isValid(String s) {        Stack<Character> stack=new Stack<Character>();        for(char c:s.toCharArray()){            //依据栈先进后出 比如检测到第一个为(,压入栈 ),            if(c=='(')            { stack.push(')');}            else if(c=='{')            { stack.push('}');}            else if(c=='[')            {stack.push(']');}            //先判断栈中是否为空 或者 c不等于栈顶的元素 就为假            else if(stack.empty()||c!=stack.pop())            {return false;}        }        if(stack.empty())        { return true;}        return false;    }    /**     将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。     */    public static List mergeTwoLists(List l1, List l2) {        List newList = new ArrayList();        for (Object o : l1) {            newList.add(o);        }        for (Object o : l2) {            newList.add(o);        }        Collections.sort(newList);        return newList;    }    /**     *在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。     * 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。     * 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。     * 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。     */    public static int[][] matrixReshape(int[][] nums, int r, int c) {        int length = 0;        List<Integer> list = new ArrayList<>();        for (int i = 0; i < nums.length; i++) {            for (int j = 0; j < nums[i].length; j++) {                length ++;                list.add(nums[i][j]);            }        }        System.out.println("nums的长度"+length);        if (length < r*c){            return nums;        }        int [][] newnums = new int[r][c];            int i=0;        for (int j = 0 ; j < r; j++) {                for (int z = 0; z < c; z++) {                    if(i < length) {                        newnums[j][z] = list.get(i);                        i++;                    }else {                        break;                    }                }        }        return newnums;    }    /**     * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。     * 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。     * 你可以假设数组中无重复元素。     */    public static int searchInsert(int[] nums, int target) {        for(int i = 0; i < nums.length; i++) {            if(nums[i] >= target) {                return i;            }        }        return nums.length;    }    /**     *在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，     * 同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。     * 返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。     * 思路:先遍历数组找数组中的0     */    public static int minKBitFlips(int[] A, int K) {        return 1;    }/** 给定一个由若干 0和 1组成的数组 A，我们最多可以将 K个值从 0变成 1 。返回仅包含 1的最长（连续）子数组的长度。 */public int longestOnes(int[] A, int K) {    //滑动窗口    return 1;}/** *给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 * 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 */    public boolean isToeplitzMatrix(int[][] matrix) {        //每一行减一的数量与自己的右下角进行比较        for (int i = 0; i < matrix.length - 1; i++) {            for (int j = 0; j < matrix[0].length; j++) {                if (matrix[i][j] != matrix[i+1][j+1]){                    return false;                }            }        }        return true;    }    /**     *给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。     * 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。     * 你可以假设除了整数 0 之外，这个整数不会以零开头。     */    public int[] plusOne(int[] digits) {        for (int i = digits.length - 1; i >= 0; i--) {            //最后一位加一            digits[i]++;            //大于两位数后进行拆分            digits[i] = digits[i] % 10;            //判断有没有进位            if (digits[i] != 0) {                return digits;}        }        //9的情况        digits = new int[digits.length + 1];        digits[0] = 1;        return digits;    }    public static void main(String[] args) {      /* int[] nums = {1,1,1,0,1,0,1,1,1,1};        int maxConsecutiveOnes = findMaxConsecutiveOnes(nums);        System.out.println(maxConsecutiveOnes);*/     /* int x = -121;       *//* int reverse = reverse(x);        System.out.println(reverse);*//*        boolean palindrome = isPalindrome(x);        System.out.println(palindrome);*/    /*  String s = "MCMXCIV";        int i = romanToInt(s);        System.out.println(i);*/    /*int[] nums = {6,2,6,5,1,2};        int i = arrayPairSum(nums);        System.out.println(i);*/ /*   List l1 = new ArrayList();    l1.add(1);    l1.add(2);    l1.add(4);        List l2 = new ArrayList();        l2.add(1);        l2.add(3);        l2.add(4);        List list = mergeTwoLists(l1, l2);        for (Object o : list) {            System.out.println(o);        }*//*     int[][] nums = {{1,2},{3,4}};        int[][] ints = matrixReshape(nums, 2, 4);        for (int i = 0; i < ints.length; i++) {            for (int i1 = 0; i1 < ints[i].length; i1++) {               System.out.println(ints[i][i1]);            }        }        */      /*int[] nums = {1,3,5,6};        int i = searchInsert(nums, 5);        System.out.println(i);*/     /* String s = "([)]";        Stack<Character> stack=new Stack<Character>();            stack.push('1');            stack.push('2');            stack.push('3');            stack.push('4');            stack.push('5');            System.out.println("pop"+stack.pop());            System.out.println("peek"+stack.peek());*/        //boolean valid = isValid(s);    }}